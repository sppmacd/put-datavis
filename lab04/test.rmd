---
title: "Short Video Platform Analytics"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE, message=TRUE, warning=TRUE}
# Load necessary packages
library(dplyr)
library(readr)
library(tibble)
library(shiny)
library(ggplot2)
library(plotly)
library(stringr)

# Load dataset (setwd() to repo/lab04)
df <- read_csv("main_chinese_data.csv")
categories_cn_en <- read_csv("categories_cn_en.csv")

# Define main city tiers for mapping
tiers_main <- c("first-tier city", "new first-tier city", "second-tier city", "third-tier city")
df$plot_tier <- ifelse(df$fre_city_level_en %in% tiers_main, df$fre_city_level_en, "other")

# Convert character engagement columns to logical (if needed) and sum up engagement
engage_cols <- c("click", "liked.", "follow", "collect", "forward")
df[engage_cols] <- lapply(df[engage_cols], function(x) as.logical(ifelse(x == "True", TRUE, FALSE)))
df$engagement <- rowSums(df[engage_cols], na.rm = TRUE)

# Function to get hourly engagement data
get_hourly_engagement <- function(hour) {
  hour <- as.numeric(hour)
  df %>%
    filter(p_hour == hour) %>%
    group_by(plot_tier) %>%
    summarise(
      total_engagement = sum(engagement, na.rm = TRUE),
      avg_engagement = mean(engagement, na.rm = TRUE),
      count = n(),
      .groups = 'drop'
    ) %>%
    arrange(desc(total_engagement))
}

# Function to get all hours data for time series
get_all_hours_data <- function() {
  df %>%
    group_by(p_hour, plot_tier) %>%
    summarise(
      total_engagement = sum(engagement, na.rm = TRUE),
      avg_engagement = mean(engagement, na.rm = TRUE),
      .groups = 'drop'
    )
}

#######################

# CUSTOM, INTERACTIVE TREE VIEW

# expr is a dataframe with "level", "id", "parent_id", "text"
renderTreeView <- function(expr) {
  # deduplicate ids
  expr <- expr %>% distinct(id, .keep_all = TRUE)

	renderNode <- function(node_id) {
    #logger::log_info(paste0(" Rendering node ID ", node_id))
		# for now just a p and proper indent
		node <- expr %>% filter(id == node_id)
    # if nodes are empty, skip (How did this happen)
    if (nrow(node) == 0) {
      #logger::log_info(paste0(" No node found for ID ", node_id))
      return()
    }
		node_text <- node$text
		# render P
		# indent based on level
    # make node_level an actual number that will work in rep/paste
    node_level <- as.integer(node$level)
    #logger::log_info(paste0("times argument: ", node_level))
    # add CSS margin dependent on level
    style <- paste0("margin-left: ", (node_level - 1) * 20, "px;")
    cat(knitr::knit_print(tags$p(
      HTML(node_text),
      style = style
    )))
	}

	renderChildren <- function(node_id) {
    #logger::log_info(paste0("Rendering children for node ID ", node_id))
		# get children
		children <- expr %>% filter(parent_id == node_id & parent_id != id)

    # skip if empty
    if (nrow(children) == 0) {
      #logger::log_info(paste0(" No children for node ID ", node_id))
      return()
    }

    #logger::log_info(paste0("  children ids: ", toString(children$id)))

		# for each child, render it and its children
		for (i in 1:nrow(children)) {
			# get child id
      #logger::log_info(" rendering child idx ", i, " of ", nrow(children), " for node ID ", node_id)
			child_id <- children$id[i]
			renderNode(child_id)
			renderChildren(child_id)
		}
	}

	# start with level 1 nodes
	l1_nodes <- expr %>% filter(level == 1)

	# render these nodes
	for (i in 1:nrow(l1_nodes)) {
    node_id <- l1_nodes$id[i]
		renderNode(node_id)
		renderChildren(node_id)
	}
}

# expr is a dataframe with "level", "id", "parent_id", "text"
convertToTree <- function(expr) {
  logger::log_info("Converting to tree view beffff")
  # new empty df
  out_df = data.frame(
    id = character(),
    name = character(),
    parent_name = character()
  )

  logger::log_info("Converting to tree view after")

  # deduplicate ids
  expr <- expr %>% distinct(id, .keep_all = TRUE)

	renderNode <- function(node_id) {
    #logger::log_info(paste0(" Rendering node ID ", node_id))
		# for now just a p and proper indent
		node <- expr %>% filter(id == node_id)
    # if nodes are empty, skip (How did this happen)
    if (nrow(node) == 0) {
      #logger::log_info(paste0(" No node found for ID ", node_id))
      return()
    }
		node_text <- node$text %>% head(1)
		# render P
		# indent based on level
    # make node_level an actual number that will work in rep/paste
    node_level <- as.integer(node$level) %>% head(1)

    # push proper indent (">") and text to out_df
    out_name = paste0(strrep("> ", node_level - 1), " ", node_text)

    logger::log_info(paste0("node: ", toString(node), "node_level: ", toString(node_level), " out_name: ", toString(out_name)))

    parent <- expr %>% filter(id == node$parent_id)
    parent_name <- ifelse(nrow(parent) > 0, parent$text, "")

    out_df <<- rbind(out_df, data.frame(id = node_id, name = out_name, parent_name = parent_name))
	}

	renderChildren <- function(node_id) {
    #logger::log_info(paste0("Rendering children for node ID ", node_id))
		# get children
		children <- expr %>% filter(parent_id == node_id & parent_id != id)

    # skip if empty
    if (nrow(children) == 0) {
      #logger::log_info(paste0(" No children for node ID ", node_id))
      return()
    }

    #logger::log_info(paste0("  children ids: ", toString(children$id)))

		# for each child, render it and its children
		for (i in 1:nrow(children)) {
			# get child id
      #logger::log_info(" rendering child idx ", i, " of ", nrow(children), " for node ID ", node_id)
			child_id <- children$id[i]
			renderNode(child_id)
			renderChildren(child_id)
		}
	}

	# start with level 1 nodes
	l1_nodes <- expr %>% filter(level == 1)

	# render these nodes
	for (i in 1:nrow(l1_nodes)) {
    node_id <- l1_nodes$id[i]
		renderNode(node_id)
		renderChildren(node_id)
	}

  return(out_df)
}
```

Overview
========

Help, about, logo etc.

Dataset from the paper ["A Large-scale Dataset with Behavior, Attributes, and Content of Mobile Short-video Platform"](https://arxiv.org/pdf/2502.05922)
(https://github.com/tsinghua-fib-lab/ShortVideo_dataset)

Categories
==========

Column
-----------------------------------------------------------------------

### Categories

```{r results = "asis"}
# category_id -> id
# category_level -> level
# category_name_en -> text
# parent_id -> parent_id
tv_data <- categories_cn_en %>% 
	select(level = category_level, 
	       id = category_id, 
	       parent_id = parent_id, 
	       text = category_name_en)
# renderTreeView(tv_data)
tv_converted <- convertToTree(tv_data)

# data table render
renderDataTable(tv_converted)
```

Column
-----------------------------------------------------------------------

### Category Stats

Engagement
==========

Column {data-width=400}
-----------------------------------------------------------------------

### Controls

```{r}
inputPanel(
  sliderInput("time_hour", 
              "Pick Hour (0-23):", 
              min = min(df$p_hour, na.rm = TRUE), 
              max = max(df$p_hour, na.rm = TRUE), 
              value = min(df$p_hour, na.rm = TRUE), 
              step = 1, round = TRUE, sep = "",
              animate = animationOptions(interval = 1200, loop = TRUE))
)
```

### City Tier Engagement (Selected Hour)

```{r}
renderPlotly({
  hour_data <- get_hourly_engagement(input$time_hour)
  
  p <- ggplot(hour_data, aes(x = reorder(plot_tier, total_engagement), 
                            y = total_engagement, 
                            fill = plot_tier)) +
    geom_col() +
    coord_flip() +
    labs(
      title = paste("Engagement by City Tier - Hour", input$time_hour),
      x = "City Tier",
      y = "Total Engagement"
    ) +
    theme_minimal() +
    theme(legend.position = "none") +
    scale_fill_viridis_d()
  
  ggplotly(p, tooltip = c("x", "y"))
})
```

Column {data-width=600}
-----------------------------------------------------------------------

### Engagement Over Time by City Tier

```{r}
renderPlotly({
  all_data <- get_all_hours_data()
  
  p <- ggplot(all_data, aes(x = p_hour, y = total_engagement, 
                           color = plot_tier, group = plot_tier)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    labs(
      title = "Engagement Throughout the Day",
      x = "Hour of Day (0-23)",
      y = "Total Engagement",
      color = "City Tier"
    ) +
    theme_minimal() +
    scale_color_viridis_d() +
    geom_vline(xintercept = input$time_hour, color = "red", linetype = "dashed", alpha = 0.7)
  
  ggplotly(p, tooltip = c("x", "y", "colour"))
})
```

### Heatmap Alternative

```{r}
renderPlotly({
  all_data <- get_all_hours_data()
  
  # Create a matrix for heatmap
  heatmap_data <- all_data %>%
    select(p_hour, plot_tier, total_engagement) %>%
    tidyr::pivot_wider(names_from = plot_tier, values_from = total_engagement, values_fill = 0)
  
  # Convert to matrix for heatmap
  mat <- as.matrix(heatmap_data[, -1])
  rownames(mat) <- heatmap_data$p_hour
  
  plot_ly(
    z = ~mat,
    x = ~colnames(mat),
    y = ~rownames(mat),
    type = "heatmap",
    colorscale = "YlOrRd",
    hovertemplate = "Hour: %{y}<br>City Tier: %{x}<br>Engagement: %{z}<extra></extra>"
  ) %>%
  layout(
    title = "Engagement Heatmap: Hour vs City Tier",
    xaxis = list(title = "City Tier"),
    yaxis = list(title = "Hour of Day")
  )
})
```
